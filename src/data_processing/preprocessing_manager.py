from .data_preprocessor import DataPreprocessor
from .sentiment_analyzer import SentimentAnalyzer
from .price_fluctuation_calculator import PriceFluctuationCalculator
from .technical_indicator_calculator import TechnicalIndicatorCalculator
from utils.data_handler import DataHandler
from logger import get_logger
import pandas as pd
from datetime import timedelta

logger = get_logger('DataProcessing')

class PreprocessingManager:
    def __init__(self, df):
        if df is None or not isinstance(df, pd.DataFrame):
            raise ValueError("Provided DataFrame is None or not a valid DataFrame.")
        if df.empty:
            logger.warning("Warning: The initial DataFrame is empty.")
        
        self.df = df
        self.logger = get_logger(self.__class__.__name__)

    def preprocess(self, target_configs, time_horizons):
        """
        General preprocessing pipeline that handles data cleaning, sentiment analysis, technical indicators, etc.

        Args:
            target_configs (List[Dict]): Configuration for dynamic target calculation.
            time_horizons (List[Dict]): List of time horizon configurations for calculating price fluctuations.
        """
        # Sentiment Analysis
        self._analyze_sentiment()

        # Price Fluctuation Calculation
        self._calculate_price_fluctuations(time_horizons)

        # Technical Indicator Calculation
        self._calculate_technical_indicators()

        # Calculate dynamic targets based on target configurations
        self.calculate_dynamic_targets(column_name='Close', target_configs=target_configs)

    def _analyze_sentiment(self):
        sentiment_analyzer = SentimentAnalyzer()
        for column in ['title', 'summary']:
            texts = self.df[column].fillna('').tolist()
            pos_probs, neg_probs, neu_probs, labels = sentiment_analyzer.analyze_sentiment(texts)
            self.df[f'{column}_positive'] = pos_probs
            self.df[f'{column}_negative'] = neg_probs
            self.df[f'{column}_neutral'] = neu_probs
            self.df[f'{column}_sentiment'] = labels

    def _calculate_price_fluctuations(self, time_horizons):
        """
        Calculate price fluctuations based on the given time horizons.
        
        Args:
            time_horizons (List[Dict]): List of time horizon configurations generated by TimeHorizonManager.
        """
        fluctuation_calculator = PriceFluctuationCalculator(self.df, time_horizons)
        self.df = fluctuation_calculator.calculate_fluctuations()

    def _calculate_technical_indicators(self):
        indicator_calculator = TechnicalIndicatorCalculator(self.df)
        self.df = indicator_calculator.calculate_rate_of_change(['RSI', 'MACD_Signal'])

    def calculate_dynamic_targets(self, column_name, target_configs):
        """
        Calculate targets based on different time horizons.

        Args:
            column_name (str): Column used for calculating targets (e.g., 'Close').
            target_configs (List[Dict]): List of configurations, each containing time_horizon and target_name.
        """
        target_dict = {}
        for config in target_configs:
            time_horizon = config['time_horizon']
            target_name = config['target_name']
            target_dict[target_name] = (
                self.df[column_name].shift(-int(time_horizon.total_seconds() // 60)) - self.df[column_name]
            )
            self.logger.info(f"Target '{target_name}' calculated.")

        target_df = pd.concat(target_dict, axis=1)
        self.df = pd.concat([self.df, target_df], axis=1)
        self.df.fillna(0, inplace=True)  # Fill any NaN with 0

    def filter_on_article_release(self):
        """
        Filters the DataFrame to include only rows where either title or summary exists.
        """
        # Log the shape and basic statistics of the DataFrame before filtering
        self.logger.info(f"Initial DataFrame shape before filtering: {self.df.shape}")
        self.logger.info(f"Number of rows with non-empty titles: {self.df['title'].notna().sum()}")
        self.logger.info(f"Number of rows with non-empty summaries: {self.df['summary'].notna().sum()}")

        # Apply filtering
        self.df = self.df[
            (self.df['title'].notna() & (self.df['title'] != "")) |
            (self.df['summary'].notna() & (self.df['summary'] != ""))
        ]

        # Log the shape after filtering
        self.logger.info(f"Filtered DataFrame shape after filtering on article release: {self.df.shape}")

        # Check if the DataFrame is empty after filtering
        if self.df.empty:
            self.logger.warning("The filtered DataFrame is empty after applying article release filter.")
        
        return self.df

class TimeHorizonManager:
    def __init__(self, start_date, end_date):
        self.start_date = pd.to_datetime(start_date)
        self.end_date = pd.to_datetime(end_date)
        self.min_horizon = timedelta(hours=2)
        self.max_horizon = timedelta(days=3)

    def generate_time_horizons(self, max_horizons=10):
        available_horizon = self.end_date - self.start_date
        time_horizons = []
        current_horizon = self.min_horizon

        while len(time_horizons) < max_horizons and current_horizon <= self.max_horizon and current_horizon <= available_horizon:
            time_horizons.append({
                'target_name': f"{int(current_horizon.total_seconds() / 3600)}_hours_change",
                'time_horizon': current_horizon
            })
            current_horizon += timedelta(hours=6)

        return time_horizons
